# -*- coding: utf-8 -*-
"""卒業研究2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y4qylwIG3Hkf-brLXPXb3dGk_XIcp9S7
"""

import pulp
from pulp import LpProblem, LpVariable, lpSum, LpMinimize, LpBinary, LpContinuous, PULP_CBC_CMD
from pulp import LpStatus
from openpyxl import *
from openpyxl import load_workbook
import os
import openpyxl
import time
import streamlit as st
import pandas as pd
from io import BytesIO

st.title("紅白戦　チーム分け　webアプリ")

uploaded_file = st.file_uploader("Excelファイルをアップロードしてください　(.xlsx)", type="xlsx")
if uploaded_file is not None:
  #アップロードされたバイトデータを読み込み
  file_bytes = uploaded_file.read()
  #openpyxlで直接読み込む
  from io import BytesIO
  wb = load_workbook(filename=BytesIO(file_bytes), data_only=True)
  #ここから「book」変数として扱う
  book=wb

  name = '選手データ＆チーム分け結果１'
  try:
    df = pd.read_excel(BytesIO(file_bytes), sheet_name='選手データ＆チーム分け結果１')
    st.subheader("アップロードされたデータ（先頭29行）")
    st.dataframe(df.head(29), use_container_width=True)
    sheet = book[name]
  except Exception as e:
    st.error(f"読み込み中にエラーが発生しました:{e}")
    st.stop()

  if st.button("チーム分けを実行"):
    with st.spinner("最適化中...少々お待ちください"):
      main_file = '結果_紅白戦.xlsx'
      sub_file = '紅白戦.xlsx'
      name = '選手データ＆チーム分け結果１'

      yomikomi=0
  #2回目以降のファイル読み込み
      if os.path.exists(main_file):
        book = load_workbook(main_file)
        yomikomi = 2
        PP = openpyxl.load_workbook('紅白戦02.xlsx', data_only = True)
        P_SUM = PP[name]
        I_num = P_SUM.max_row - 3
  #1回目のファイル読み込み
      elif os.path.exists(sub_file):
        book = load_workbook(sub_file)
        yomikomi = 1
        PP = openpyxl.load_workbook('紅白戦.xlsx', data_only = True)
        P_SUM = PP[name]
        I_num = P_SUM.max_row - 3
      else:
        st.error("対象ファイルがありません")
        st.stop()

      sheet = book[name]

      J_num = 9
      T_num = 2

      I = [i+1 for i in range(I_num)]
      J = [j+1 for j in range(J_num)]
      T = [t+1 for t in range(T_num)]

      E = {}#出場欠場
      reg = 0
      for i in I:
        if sheet.cell(row=2+i, column=3).value is not None:
          E[i] = sheet.cell(row=2+i, column=3).value
          reg += 1

      EE = 0
      for i in range(1,reg+1):
        EE += E[i]

      P = {}#ポジションの評価値
      for i in range(1,reg+1):
        for j in J:
          P[(i, j)] = sheet.cell(row=2+i, column=3+j).value

      WP = {}#守りたいポジション
      for i in range(1,reg+1):
        WP[i] = sheet.cell(row=2+i, column=13).value


      B = {}#打撃力の評価値
      for i in range(1,reg+1):
        B[(i)] = sheet.cell(row=2+i, column=14).value


      problem = LpProblem('kouhaku', LpMinimize)


      #過去の紅白戦のチーム読み込み
      n_count = 0
      if yomikomi == 2:
        tt = {}
        while sheet.cell(row=3, column=15+n_count).value is not None:
          n_count += 1
        for c in range(1,n_count+1):
            for i in range(1,reg+1):
              tt[i, c] = sheet.cell(row=2+i, column=14+c).value

      sheet = book['チーム分け結果詳細']
      for i_count in range(I_num):
        for t_count in range(10):
          sheet.cell(row=3+i_count, column=3+t_count).value = None

      #一つ前の紅白戦で同じチームの選手は1、そうじゃなければ0
      A = {}
      n = 0
      if yomikomi==2:
          for c in range(1,n_count+1):
            for i in range(1,reg):
              for ii in range(i+1,reg+1):
                if c == 1:
                  A[i, ii] = 0
                if tt[i, c] == tt[ii, c] and tt[i, c] >= 1  and tt[ii, c] >= 1:
                  A[i, ii] += 1
          for i in range(1,reg):
                for ii in range(i+1,reg+1):
                  A[i, ii] = A[i, ii]/n_count
      elif yomikomi==1:
        for i in range(1,reg):
          for ii in range(i+1,reg+1):
            A[i, ii] = 0


      #目的関数
      x = {}
      for i in range(1,reg+1):
        for j in J:
          for t in T:
            if E[i] == 1 and P[(i,j)] > 0:
              x[(i, j, t)] = LpVariable(f'x_{i}_{j}_{t}', cat=LpBinary)


      #iとiiが同じチームであるときに1,そうでないとき0
      Y = {}
      for i in range(1,reg):
        if E[i] == 1:
          for ii in range(i+1,reg+1):
            if E[ii] == 1:
              Y[(i,ii)] = LpVariable(f'y_{i}_{ii}', cat=LpBinary)


      ##制約条件
      #出場する選手が欠場したり、欠場する選手が出場したりすることがない
      for i in range(1,reg+1):
        problem += lpSum(x[(i,j,t)] for j in J for t in T if (i,j,t) in x) == E[i], f"constraint_attend_{i}"

      #チーム振り分けの際に両チームの人数をできるだけ均等にする
      for t in T:
          problem += lpSum(x[i,j,t] for i in range(1,reg+1) for j in J if (i,j,t) in x) >= EE//2, f"constraint_team_size_{t}"

      #1チーム内で各ポジション守れる選手を一人以上選ぶこと
      for j in J:
        for t in T:
          problem += lpSum(x[(i,j,t)] for i in range(1,reg+1) if (i,j,t) in x) >= 1, f"constraint_position_{j}_{t}"

      #1チーム内でピッチャーを守れる選手を2人以上選ぶこと
      count_pitcher = 0
      for i in range(1,reg+1):
        if P[(i,1)] >= 1:
          count_pitcher += 1

      if count_pitcher >= 4:
        for t in T:
          problem += lpSum(x[(i,1,t)] for i in range(1,reg+1) if (i,1,t) in x) >= 2, f"constraint_pitcher_{t}"

      #守らせたいポジションがある選手はそのポジションを守らせる
      for i in range(1,reg+1):
        if WP[i] > 0:#and E[i] == 1:
          problem += lpSum(x[(i,WP[i],t)] for t in T if (i,WP[i],t) in x) == 1, f"constraint_want_pojition_{i}"

      #過去の紅白戦で同じチームになった選手はできるだけ違うチームに振り分ける
      for i in range(1,reg):
        for ii in range(i+1,reg+1):
          for t in T:
            if (i,ii) in Y:
              problem += Y[(i,ii)] >= lpSum(x[(i,j,t)] for j in J if (i,j,t) in x) + lpSum(x[(ii,j,t)] for j in J if (ii,j,t) in x) - 1, f"constraint_prior_same_team_{i}_{ii}_{t}"

      #絶対値
      z = LpVariable('z', lowBound=0, cat=LpContinuous)

      power={}
      for t in T:
        power[t] = lpSum((P[(i,j)]+B[(i)])*(x[(i,j,t)]) for i in range(1,reg+1) for j in J if (i,j,t) in x)

      problem += z >= -(power[1]-power[2]), "constraint_abs1"
      problem += z >= power[1]-power[2], "constraint_abs2"

      #最小化実行
      problem += 100*z + lpSum(A[i,ii]*Y[(i,ii)]for i in range(1,reg) if E[i] == 1 for ii in range(i+1,reg+1) if E[ii] == 1), "Objective"

      problem.writeLP('kouhaku.lp')

      st.write("最適化開始")
      start_time = time.time()
      status = problem.solve(PULP_CBC_CMD(timeLimit=60, msg=True))
      end_time = time.time()
#pulp.LpStatus[status]
      st.write("最適化終了")
      elapsed_time = end_time - start_time
      st.write(f"最適化実行時間: {elapsed_time:.3f}秒")
      st.write(f"ステータス: {pulp.LpStatus[status]}")



#エクセル出力

      if pulp.LpStatus[status] == 'Optimal':
        st.write("結果をExselに書き込みます...")
        for i in range(1,reg+1):
          for j in J:
            for t in T:
              if (i,j,t) in x and x[(i,j,t)].varValue >= 0.99:
                sheet = book[name]
                sheet.cell(row=2+i,column=15+n_count).value = t
                sheet = book['チーム分け結果詳細']
                sheet.cell(row=2+i,column=2+(5*t-4)).value = 1
                sheet.cell(row=2+i,column=3+(5*t-4)).value = j
                sheet.cell(row=2+i,column=4+(5*t-4)).value = P[(i,j)]
                sheet.cell(row=2+i,column=5+(5*t-4)).value = B[(i)]
                sheet.cell(row=2+i,column=6+(5*t-4)).value = P[(i,j)]+B[(i)]

        sheet = book[name]
        for i in range(1,reg+1):
          if sheet.cell(row=2+i, column=15+n_count).value is None:
            sheet.cell(row=2+i, column=15+n_count).value = 0

        save_filename = f"紅白戦{n_count}.xlsx"
        book.save(save_filename)

        #保存
        output_stream = BytesIO()
        book.save(output_stream)
        output_stream.seek(0)

        try:
            df_result = pd.read_excel(output_stream, sheet_name='チーム分け結果詳細')
        except Exception as e:
            st.error(f"結果読み込み中にエラーが発生しました：{e}")
            st.download_button(
                label="結果ファイルをダウンロード",
                data=output_stream.getvalue(),
                file_name=f"{uploaded_file.name}",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
            st.stop()
                
        st.subheader("最適化結果（チーム分け結果）")
        st.dataframe(df_result, use_container_width=True)

        file_name = f"紅白戦{n_count}.xlsx"

        st.download_button(
            label="結果ファイルをダウンロード",
            data=output_stream,
            file_name=f"{uploaded_file.name}",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )

        #book.save('紅白戦02.xlsx')

      elif elapsed_time >= 60:
        st.write("結果をExselに書き込みます...")
        for i in range(1,reg+1):
          for j in J:
            for t in T:
              if (i,j,t) in x and x[(i,j,t)].varValue >= 0.99:
                sheet = book[name]
                sheet.cell(row=2+i,column=15+n_count).value = t
                sheet = book['チーム分け結果詳細']
                sheet.cell(row=2+i,column=2+(5*t-4)).value = 1
                sheet.cell(row=2+i,column=3+(5*t-4)).value = j
                sheet.cell(row=2+i,column=4+(5*t-4)).value = P[(i,j)]
                sheet.cell(row=2+i,column=5+(5*t-4)).value = B[(i)]
                sheet.cell(row=2+i,column=6+(5*t-4)).value = P[(i,j)]+B[(i)]

        sheet = book[name]
        for i in range(1,reg+1):
          if sheet.cell(row=2+i, column=15+n_count).value is None:
            sheet.cell(row=2+i, column=15+n_count).value = 0

        save_filename = f"紅白戦{n_count}.xlsx"
        book.save(save_filename)

        #保存
        output_stream = BytesIO()
        book.save(output_stream)
        output_stream.seek(0)

        try:
            df_result = pd.read_excel(output_stream, sheet_name='チーム分け結果詳細')
        except Exception as e:
            st.error(f"結果読み込み中にエラーが発生しました：{e}")
            st.download_button(
                label="結果ファイルをダウンロード",
                data=output_stream.getvalue(),
                file_name=f"{uploaded_file.name}",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
            st.stop()

        st.subheader("最適化結果（チーム分け結果）")
        st.dataframe(df_result, use_container_width=True)

        file_name = f"紅白戦{n_count}.xlsx"

        st.download_button(
            label="結果ファイルをダウンロード",
            data=output_stream,
            file_name=f"{uploaded_file.name}",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        )
      else:
        st.error("最適解が得られませんでした。")
